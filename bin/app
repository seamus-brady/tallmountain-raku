#!/usr/bin/env raku

#  Copyright (c) 2024. Prediction By Invention https://predictionbyinvention.com/
#
#  THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
#  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
#  PARTICULAR PURPOSE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
#  IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR
#  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use v6.d;
use lib 'lib';
use Util::Logger;
use Cro::HTTP::Server;
use Cro::HTTP::Router;
use Cro::HTTP::Log::File;
use Cro::HTTP::Middleware;
use Cycle::Cognitive;
use Cycle::Payload::TaintedString;

# set up logger
my $APP_LOGGER = Util::Logger.new(namespace => "<TallMountain App>");

# set up chat request and response channels
my Supplier $chat-request-supplier = Supplier.new;
my Supply $chat-request-supply = $chat-request-supplier.Supply;
my Channel $chat-response-channel = Channel.new;

class TallMountainHTTPLogger does Cro::HTTP::Middleware::Response {
    # Log the HTTP request and response
    has IO::Handle $.logs;
    has IO::Handle $.errors;
    has Bool $.flush;

    submethod BUILD(:$logs, :$errors, :$!flush = True) {
        with $logs {
            $!logs = $logs;
            with $errors { $!errors = $errors } else { $!errors = $logs }
        }
        else {
            $!logs = $*OUT;
            with $errors { $!errors = $errors } else { $!errors = $*ERR }
        }
    }

    method process(Supply $pipeline --> Supply) {
        supply {
            whenever $pipeline -> $resp {
                if $resp.status < 400 {
                    $!logs.say: "[OK] {$resp.status} {$resp.request.original-target} - {$resp.request.connection.peer-host}";
                    $APP_LOGGER.debug( "<Cro Web Server> [OK] {$resp.status} " ~
                            "{$resp.request.original-target} - {$resp.request.connection.peer-host}");
                    $!logs.flush if $!flush;
                } else {
                    $!errors.say: "[ERROR] {$resp.status} {$resp.request.original-target} - {$resp.request.connection.peer-host}";
                    $APP_LOGGER.error("<Cro Web Server> [ERROR] {$resp.status} " ~
                            "{$resp.request.original-target} - {$resp.request.connection.peer-host}");
                    $!errors.flush if $!flush;
                }
                emit $resp;
            }
        }
    }
}

sub routes() {
    # Set up the routes for the chat UI
    route {
        # process the user message and return the response

        post -> 'chat' {
            try {
                # get the user message from the request body
                my $prompt;
                request-body -> %fields {
                    $prompt = %fields<message>;
                }
                $APP_LOGGER.debug("Received user message: '$prompt'");
                $chat-request-supplier.emit($prompt);

                # get the bot reply
                my $bot-response = $chat-response-channel.receive;
                $APP_LOGGER.debug("Received bot reply: '$bot-response'");

                # return the response as an htmx fragment
                my $htmx-fragment = get_response($prompt, $bot-response);
                content 'text/html', $htmx-fragment;
            }
            CATCH {
                default {
                    $APP_LOGGER.error("Error processing /chat route: $_");
                    content 'text/html', q:to/END/;
                    <h1>Error Processing Route: A Haiku</h1>
                    Typing, then silence,<p>
                    Echoes of thoughts left unread,<p>
                    Chats lost in the void. <p>
                    END
                }
            }
        }

        # serve the chat UI
        get -> {
            try {
                static 'www/chat_ui.html';
            }
            CATCH {
                default {
                    $APP_LOGGER.error("Error serving chat UI: $_");
                    content 'text/html', q:to/END/;
                    <h1>Error Serving Chat UI: A Haiku</h1>
                    Still the server hums, <p>
                    Yet the page you seek is gone, <p>
                    A void answers back. <p>
                    END
                }
            }
        }
        after {
            if .status == 404 && !.has-body {
                content 'text/html',  q:to/END/;
                <h1>Not Found: A Haiku</h1>
                Lost in the vast web,<p>
                A home that no longer speaks,<p>
                404 remains.<p>
                END
            }
            if .status != 200 && !.has-body {
                content 'text/html', q:to/END/;
                <h1>Phantom Request: A Haiku</h1>
                Broken web echoes,<p>
                Unknown paths lead to shadows,<p>
                Browsers pause, confused.<p>
                END
            }
        }
    }
}


sub get_response(Str $prompt, Str $bot-response --> Str){
    # Return the response as an htmx fragment
    my Str $response =  qq:to/END/;
        <div class="message-container user-message-container">
        <img src="https://img.icons8.com/color/48/000000/user.png" class="icon" alt="User Icon">
        <span>{$prompt}</span>
        </div>
        <div class="message-container bot-message-container">
        <img src="https://img.icons8.com/ios-filled/50/4a90e2/mountain.png" class="icon" alt="Bot Icon">
        <span class="bot-message">{$bot-response}</span>
        </div>
        END
    return $response.trim;
}

sub check-api-key {
    # Check for OPENAI_API_KEY environment variable if using OpenAI
    if Util::Config.get_config('llm', 'default_llm_provider') ~ "openai" {
        my $api-key = %*ENV<OPENAI_API_KEY>;
        if not $api-key.defined {
            my $msg = "OPENAI_API_KEY environment variable not found";
            $APP_LOGGER.debug($msg);
            die $msg;
        }
    }
}

sub init-cro-service (--> Cro::Service) {
    # Start the chat ui server
    my $host = Util::Config.get_config('chat_ui', 'chat_ui_server');
    my $port = Util::Config.get_config('chat_ui', 'chat_ui_port');
    my Cro::Service $http = Cro::HTTP::Server.new(
            http => <1.1>,
            host => $host,
            port => $port,
            application => routes(),
            after => [
                TallMountainHTTPLogger.new(logs => $*OUT, errors => $*ERR)
            ]
            );
    return $http;
}

sub MAIN() {

    # log the start of the app
    $APP_LOGGER.debug("Starting TallMountain App... please wait");

    # make sure we have an API key
    check-api-key;

    # start the web server for the chat ui
    $APP_LOGGER.debug("Starting the web server for the chat UI...");
    my Cro::Service $http = init-cro-service;
    $http.start;

    # get a cognitive cycle instance
    $APP_LOGGER.debug("Getting a cognitive cycle instance...");
    my $cycle = Cycle::Cognitive.new;

    $APP_LOGGER.debug("TallMountain App started successfully and waiting for user requests...");

    # Start the cognitive cycle
    start {
        react {
            # Whenever a chat request is received, process it
            whenever $chat-request-supply -> $request {
                $APP_LOGGER.debug("App received user request: '$request'");

                # get a response but wrap in a tainted string
                my $tainted-string = Cycle::TaintedString.new(payload => $request);
                my $response = $cycle.run-one-cycle($tainted-string);
                $APP_LOGGER.debug("App received bot response: '$response'");

                # return the response
                $chat-response-channel.send($response);
            };
        }
    }

    react {
        whenever signal(SIGINT) {
            $APP_LOGGER.debug("Received SIGINT signal... shutting down...");
            say "Shutting down...";
            $APP_LOGGER.debug("Stopping the web server for the chat UI...");
            $http.stop;
            done;
        }
    }
}