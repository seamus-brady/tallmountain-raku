#!/usr/bin/env raku

#  Copyright (c) 2024. Prediction By Invention https://predictionbyinvention.com/
#
#  THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
#  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
#  PARTICULAR PURPOSE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
#  IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR
#  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use v6.d;
use lib 'lib';
use Util::Logger;
use Normative::Agent;
use Normative::Analysis::ImpliedNormExtractor;
use Normative::Analysis::SelfDiagnostic;
use Cycle::Cognitive;
use Cycle::Payload::TaintedString;

# set up logger
my $APP_LOGGER = Util::Logger.new(namespace => "<TallMountain App>");

use Linenoise;

sub check_api_key {
    # Check for OPENAI_API_KEY environment variable if using OpenAI
    if Util::Config.get_config('llm', 'default_llm_provider') ~ "openai" {
        my $api-key = %*ENV<OPENAI_API_KEY>;
        if not $api-key.defined {
            my $msg = "OPENAI_API_KEY environment variable not found";
            $APP_LOGGER.debug($msg);
            die $msg;
        }
    }
}

sub perform_self_diagnosis {
    # Perform a self-diagnosis to check all internal norms are consistent
    $APP_LOGGER.debug("Running the normative calculus self-diagnostic...");
    my $np-agent = Normative::Agent.new;
    $np-agent.init;
    my $diagnostic = Normative::Analysis::SelfDiagnostic.new;
    my %diagnostic-result = $diagnostic.run_diagnostic($np-agent);
    if %diagnostic-result<PassedDiagnostic> eq "False" {
        my Str $analysis = %diagnostic-result<Analysis>;
        my $msg = "Sorry, the normative calculus self-diagnostic failed: $analysis";
        $APP_LOGGER.debug($msg);
        die $msg;
    } else {
        $APP_LOGGER.debug("Normative calculus self-diagnostic passed successfully!");
    }
}

sub format_implied_propositions(%hash) {
    say "implied_propositions:";
    for %hash<implied_propositions><NormativeProposition>.list -> $prop {
        say "    - level: {$prop<level>}";
        say "      modal_subscript: {$prop<modal_subscript>}";
        say "      modality: {$prop<modality>}";
        say "      operator: {$prop<operator>}";
        say "      proposition_value: {$prop<proposition_value>}\n";
    }
    say "input_statement:\n    {%hash<input_statement>}";
}


sub MAIN() {
    # log the start of the app
    $APP_LOGGER.debug("Starting TallMountain REPL... please wait");

    # make sure we have an API key
    check_api_key;

    # make sure the normative calculus is consistent
    perform_self_diagnosis;

    # get a cognitive cycle instance
    $APP_LOGGER.debug("Getting a cognitive cycle instance...");
    my $cycle = Cycle::Cognitive.new;
    say "=== Welcome to TallMountain Mk 31. Type ':help' for a list of commands or :quit to exit ===";
    while (my $line = linenoise 'TallMountain (USER):> ').defined {
        try {

            if $line eq ':quit' {
                say "Goodbye!";
                last;
            }

            if $line eq ':help' {
                $APP_LOGGER.debug("User requested help information.");
                say "Available commands:
                :quit       - Exit the REPL
                :help       - Show this help message
                :extract_np <query> - Extracts normative propositions from a query";
                next;
            }

            if $line.contains(':extract_np') {
                my @parts = $line.split(/\s+/);
                my $query = @parts[1..*].join(" ");
                my $norm_extractor = Normative::Analysis::ImpliedNormExtractor.new;
                my %norm_props = $norm_extractor.extract_norm_props($query);
                format_implied_propositions(%norm_props);
                next;
            }

            # get a response but wrap in a tainted string
            my $tainted-string = Cycle::Payload::TaintedString.new(payload => $line);
            my $response = $cycle.run-one_cycle($tainted-string);
            say "TallMountain (TMAI):> $response";

            CATCH {
                default {
                    say "An error occurred: $_";
                    next;
                }
            }
        }
    }
}