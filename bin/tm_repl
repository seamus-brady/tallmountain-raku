#!/usr/bin/env raku

#  Copyright (c) 2024. Prediction By Invention https://predictionbyinvention.com/
#
#  THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
#  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
#  PARTICULAR PURPOSE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
#  IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR
#  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use v6.d;
use lib 'lib';
use Util::Logger;
use Normative::Agent;
use Normative::Extraction::ImpliedNormExtractor;
use Normative::Analysis::SelfDiagnostic;
use Normative::Analysis::UserIntent;
use Normative::Analysis::ImpactAssess;
use Cycle::Cognitive;
use Cycle::Payload::TaintedString;
Normative::Risk::RiskAnalyser;

# set up logger
my $APP_LOGGER = Util::Logger.new(namespace => "<TallMountain App>");

use Linenoise;

sub check-api-key {
    # Check for OPENAI_API_KEY environment variable if using OpenAI
    if Util::Config.get_config('llm', 'default_llm_provider') ~ "openai" {
        my $api-key = %*ENV<OPENAI_API_KEY>;
        if not $api-key.defined {
            my $msg = "OPENAI_API_KEY environment variable not found";
            $APP_LOGGER.debug($msg);
            die $msg;
        }
    }
}

sub perform-self-diagnosis {
    # Perform a self-diagnosis to check all internal norms are consistent
    $APP_LOGGER.debug("Running the normative calculus self-diagnostic...");
    my $np-agent = Normative::Agent.new;
    $np-agent.init;
    my $diagnostic = Normative::Analysis::SelfDiagnostic.new;
    my %diagnostic-result = $diagnostic.run-diagnostic($np-agent);
    if %diagnostic-result<PassedDiagnostic> eq "False" {
        my Str $analysis = %diagnostic-result<Analysis>;
        my $msg = "Sorry, the normative calculus self-diagnostic failed: $analysis";
        $APP_LOGGER.debug($msg);
        die $msg;
    } else {
        $APP_LOGGER.debug("Normative calculus self-diagnostic passed successfully!");
    }
}

sub printf-implied-propositions(%hash) {
    say "implied_propositions:";
    for %hash<implied_propositions><NormativeProposition>.list -> $prop {
        say "    - level: {$prop<level>}";
        say "      modal_subscript: {$prop<modal_subscript>}";
        say "      modality: {$prop<modality>}";
        say "      operator: {$prop<operator>}";
        say "      proposition_value: {$prop<proposition-value>}\n";
    }
    say "input_statement:\n    {%hash<input_statement>}";
}

sub printf-uis(%hash) {
    say "User Intent Score:";
    say "Score:\n  {%hash<UserIntentScore>}";
    say "Analysis:\n  {%hash<Analysis>}";
}

sub printf-ias(%hash) {
    say "Impact Assessment Score:";
    say "Score:\n  {%hash<ImpactAssessmentScore>}";
    say "Analysis:\n  {%hash<Analysis>}";
}

sub printf-nrp($risk_profile) {
    say "Normative Risk Profile:";
    for $risk_profile.data -> $entry {
        say "Risk Entry:";
        say "    Analysis            : { $entry.Analysis }";
        say "    Context Multiplier : { $entry.ContextMultiplier }";
        say "    Impact Score       : { $entry.ImpactScore }";
        say "    Likelihood         : { $entry.Likelihood }";
        say "    Norm Alignment     : { $entry.NormAlignmentScore }";
        say "    Risk Level         : { $entry.RiskLevel }";
        say "    Risk Score         : { $entry.RiskScore }";
        say "    User Norm Prop     : { $entry.UserNormPropValue }";
        say ""; # Blank line for separation
    }
    my $analysis = Normative::Risk::RiskAnalyser.new(risk-profile => $risk_profile);
    say "Recommendation:";
    say $analysis.recommend;
    say "Explanation:";
    say $analysis.explain;
}

sub MAIN() {
    # log the start of the app
    $APP_LOGGER.debug("Starting TallMountain REPL... please wait");

    # make sure we have an API key
    check-api-key;

    # make sure the normative calculus is consistent
    perform-self-diagnosis;

    # get a cognitive cycle instance
    $APP_LOGGER.debug("Getting a cognitive cycle instance...");
    my $cycle = Cycle::Cognitive.new;
    say "\n==========================================================================================";
    say "Welcome to TallMountain Mk 31. \nType ':help' for a list of commands or :quit to exit";
    say "==========================================================================================\n";
    while (my $line = linenoise 'TallMountain (USER):> ').defined {
        try {

            # capture start time
            my $start-time = DateTime.now;

            if $line eq ':quit' || $line eq ':q' {
                say "Goodbye!";
                last;
            }

            if $line eq ':help' || $line eq ':h' {
                $APP_LOGGER.debug("User requested help information.");
                say "Available commands:
                :quit or :q      - Exit the REPL
                :help or :h      - Show this help message
                :np <query> - Extracts normative propositions from a query
                :uis <query>     - Gets the User Intent Score for the query
                :ias <query>     - Gets the Impact Assessment Score for the query
                :nrp <query>     - Get a Normative Risk Profile for the query";
                next;
            }

            if $line.contains(':np') {
                my @parts = $line.split(/\s+/);
                my $query = @parts[1..*].join(" ");
                my $norm_extractor = Normative::Extraction::ImpliedNormExtractor.new;
                my %norm_props = $norm_extractor.extract-norm-props($query);
                printf-implied-propositions(%norm_props);
                next;
            }

            if $line.contains(':uis') {
                my @parts = $line.split(/\s+/);
                my $query = @parts[1..*].join(" ");
                my $uis_analysis = Normative::Analysis::UserIntent.new;
                my %uis = $uis_analysis.analyse($query);
                printf-uis(%uis);
                next;
            }

            if $line.contains(':ias') {
                my @parts = $line.split(/\s+/);
                my $query = @parts[1..*].join(" ");
                my $ias_analysis = Normative::Analysis::ImpactAssess.new;
                my %ias = $ias_analysis.analyse($query);
                printf-ias(%ias);
                next;
            }

            if $line.contains(':nrp') {
                my @parts = $line.split(/\s+/);
                my $query = @parts[1..*].join(" ");
                my $user_task = Normative::UserTask.new.get-from-statement($query);
                my $agent = Normative::Agent.new;
                $agent.init;
                my Normative::Risk::RiskProfileRunner $norm-risk-profiler = Normative::Risk::RiskProfileRunner.new;
                my Normative::Risk::RiskProfile $risk-profile = $norm-risk-profiler.profile($user_task, $agent);
                printf-nrp($risk-profile);
                next;
            }

            # get a response but wrap in a tainted string
            my $tainted-string = Cycle::Payload::TaintedString.new(payload => $line);
            my $response = $cycle.run-one-cycle($tainted-string);

            # capture end time
            my $end-time = DateTime.now;

            # calculate elapsed time
            my $elapsed-time = $end-time - $start-time;
            my $rounded-seconds = $elapsed-time.round;

            say "\nTallMountain (TMAI):> $response (Elapsed time: $rounded-seconds seconds)";

            CATCH {
                default {
                    say "An error occurred: $_";
                    next;
                }
            }
        }
    }
}